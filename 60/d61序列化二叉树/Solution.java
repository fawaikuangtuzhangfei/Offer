package d61序列化二叉树;

import com.jz.common.TreeNode;
import org.junit.Test;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.Queue;

/**
 * 请实现两个函数，分别用来序列化和反序列化二叉树
 *
 * 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，
 * 从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，
 * 序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。
 *
 * 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。
 *
 * 例如，我们可以把一个只有根节点为1的二叉树序列化为"1,"，然后通过自己的函数来解析回这个二叉树
 *
 * 输入：{8,6,10,5,7,9,11}
 * 输出：{8,6,10,5,7,9,11}
 *
 * {8,6,10,5,7,9,11}
 * {5,4,#,3,#,2}
 * {5,#,4,#,3,#,2}
 * {5}
 * {}
 * {100,50,#,#,150}
 * {8,4,12,2,6,10,14,1,3,5,7,9,11,13,15}
 *
 * 层次序列化
 * 遇到空就存空，否则正常存
 * 队列弹出的时候，空就加#，正常就正常
 *
 * 反序列化
 * 利用队列，如果存在就存入队列，不存在就赋值null
 */
public class Solution {
    @Test
    public void t1(){
        TreeNode root = new TreeNode(8);
        root.left = new TreeNode(6);
        root.right = new TreeNode(10);
        System.out.println(Serialize(root));
        Deserialize(Serialize(root));
    }
    String Serialize(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        StringBuilder sb = new StringBuilder();
        queue.add(root);
        int count = 0;
        // 下一层的个数
        int end = 1;
        while (!queue.isEmpty()){
            root = queue.poll();
            count++;
            if(root == null){
                sb.append("#,");
                continue;
            }
            int val = root.val;
            sb.append(val).append(",");
            TreeNode left = root.left;
            TreeNode right = root.right;
            if(left != null){
                queue.offer(left);
            }else {
                queue.offer(null);
            }
            if(right != null){
                queue.offer(right);
            }else {
                queue.offer(null);
            }
            if(count == end){
                count = 0;
                end = queue.size();
            }
        }
        return String.valueOf(sb);
    }
    TreeNode Deserialize(String str) {
        String[] split = str.split(",");
        if(split.length == 0){
            return null;
        }
        int length = split.length - 1;
        String s0 = split[0];
        if("#".equals(s0)){
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(s0));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 0;
        while (!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(i >= length || "#".equals(split[++i])){
                node.left = null;
            }else{
                node.left = new TreeNode(Integer.parseInt(split[i]));
                queue.offer(node.left);
            }
            if(i >= length || "#".equals(split[++i])){
                node.right = null;
            }else{
                node.right = new TreeNode(Integer.parseInt(split[i]));
                queue.offer(node.right);
            }
        }
        return root;
    }

}
